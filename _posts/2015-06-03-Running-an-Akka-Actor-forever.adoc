= Running an Akka Actor forever
:hp-tags: scala, akka, fault tolreant

I work on a project that runs as a single process and does many things. I was also reading about http://akka.io[Akka] for a while and wanted to use it.
This seemed to be a very good use case where I could learn and add value to the existing project.  

This is my first time working with http://akka.io[Akka] and http://www.scala-lang.org[Scala] so if you find my code not using recommended practices, please let me know, I would love to improve on it.

For the purposes of this post, let's consider we have *Runner* (who we expect to run long and forever) and a *Coach* (who will look after *Runner*).

The relationship could be visualized as 

image::/images/actor_run_forever_0.png[initial hierarchy]


The *Runner* is expected to run a *Race*, which looks like

[source, scala]
----
import scala.concurrent.Future

case object Start

case object Stop

case object StartWithFuture

trait Race {
  def start: Future[Any]
}

class Marathon extends Race {

  import scala.concurrent.ExecutionContext.Implicits.global

  override def start: Future[Any] = Future {
    println("running long job in future")
    for (i <- 1 to 3) {
      Thread.sleep(200)
    }
    throw new RuntimeException("MarathonRunner is tired")
  }
}
----

The *Marathon* _is a_ *Race* whis is supposed to run longer, but in our case we are making it fail so that we can assert when our *Runner* fails, the *Coach* starts it up again.

Our *Runner* looks like  

[source, scala]
----
import akka.actor.Status.Failure
import akka.actor.{Actor, ActorLogging, Props}
import akka.event.LoggingReceive

object Runner {
  def props(race: Race) = Props(classOf[Runner], race)
}

class Runner(race: Race) extends Actor with ActorLogging {

  override def receive: Receive = LoggingReceive {
    case Start =>
      sender ! "OK"
      log.debug("running...")
      Thread.sleep(10)
      throw new RuntimeException("MarathonRunner is tired")

    case Failure(throwable) => throw throwable

    case Stop =>
      log.debug("stopping runner")
      context.stop(self)
  }
}
----
Our *Runner* is an http://doc.akka.io/docs/akka/snapshot/scala/actors.html[Actor] which is defined to do specific task when it receives a known message. For example, in our case *Runner* will only work if he receives one of messages in *Start*, *Failure* and *Stop*

Once our *Runner* is ready, we need to see what our *Coach* does with this *Runner*

[source, scala]
----
import akka.actor.SupervisorStrategy.Restart
import akka.actor._
import akka.event.LoggingReceive

import scala.concurrent.duration._

case object StartWork

case object RestartRunner

object Coach {
  def props(): Props = Props[Coach]
}

class Coach() extends Actor with ActorLogging {

  val runner = context.actorOf(Runner.props(new Marathon).withDispatcher("my-pinned-dispatcher"), "runner")

  override def supervisorStrategy: SupervisorStrategy = OneForOneStrategy(maxNrOfRetries = 2, withinTimeRange = 5 seconds) {
    case _: RuntimeException =>
      sender ! Start
      Restart
  }

  override def receive = LoggingReceive {
    case StartWork => runner ! Start

    case RestartRunner =>
      log.debug("runner restarted, sending message to Run")
      self ! StartWork
  }
}
----
As we can see *Coach* is also an Actor which does specific tasks based on the messages it receives. In this case, Actor does 2 things different from our *Runner* Actor  

. Creating *Runner* Actor: 


 